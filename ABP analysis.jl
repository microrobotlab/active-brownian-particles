
# PURPOSE: Calculate the packing fraction of particles at the equators or poles
# METHOD: Absolute angle is calculated w.r.t centre of the ellipse
# INPUT: data from a file generated by ABP file.jl 
# OUTPUT: Plot of packing fractions and a file of number of particles at equators and poles
#OUTPUT: Plot of number of particles at the left and right hand side of the ellipse for symmetry_analysis
using  Plots, LaTeXStrings, Statistics, CSV, DataFrames,CategoricalArrays

gr()

function stat_analysis1(a,b,R,pathf,δt,symmetry)
  
  fmain= pathf*".csv"
  df= CSV.read(fmain, DataFrame)
  @show time= unique(df[!,:StepN])*δt  # not to repeat the time in data df[!,:StepN]*δt
  df[!,:StepN] = categorical(df[!,:StepN],compress=true) # it sorts out time step data 

  ## Group dataframe by values in categorical column
  gdf = groupby(df,:StepN,sort=true) # only 1000 data groups because I have omitted 100 time steps means 1 s


  if symmetry == 0
    # for number of particles at the poles and equators run this function
    curvature_analysis(a,b,R,time,gdf,pathf,δt)    
  elseif symmetry == 1
    # for number of particles at the left or right side of the ellipse run this function
    symmetry_analysis(a,b,R,time,gdf,pathf,δt)
  elseif  symmetry == 2
    # for number of particles at the left or right side of the ellipse run this function
    symmetry_analysis(a,b,R,time,gdf,pathf,δt)
    curvature_analysis(a,b,R,time,gdf,pathf,δt)
    
    return nothing
  end
 
end

function symmetry_analysis(a,b,R,time,gdf,pathf,δt)
 
  f1= pathf*"_symmetry_analysis_p.csv"
  f2= pathf*"_symmetry_analysis_N.png"
  f3= pathf*"_symmetry_analysis_Ndiff.png"
  
  n_right,n_left=[], []
  i= (time/δt)
   # angle at which area will be same

  for i=1:length(gdf)      # length(gdf) is total time or steps, i is actually time steps but in group counting it is 1, 2, 3---1000 , hence, time                                                                                                                                                                                                                     
   global right=0
   global left=0
  
   
    for j=1:length(gdf[i][!,:xpos]) 
    
        θ = atan.(gdf[i][!,:ypos][j], gdf[i][!,:xpos][j]) 

        if θ.>= -(π/2)  && θ.<= π/2                    #Right ellipse                                                                                                                                                                                     
           global  right+=1  
             elseif θ.>= π/2 && θ.<= π                 # Left ellipse
              global  left+=1 
                elseif θ.>= -(π)   && θ.<= -π/2        # Left ellipse
                global    left+=1 
    end   
    
    end
    push!(n_right,right)
    push!(n_left,left)
  
    count= right+left
 
  end

  
############################################################################################################
#file wriiting
    touch(f1)

    efg = open(f1, "w")
    #time1= unique(df[!,:StepN])  # not to repeat the time in data

        #########################################################################################
    # ploting in terms of particles number
    yl1=100
    xl=100
  #  xlabel!("Time (s)", xguidefont=font(11), xtickfont=font(11))
  #  plot!(ylabel=L"\mathrm{N_{eqs}}",yguidefont=font(11), ytickfont=font(11))
   
   t1= scatter(time,n_left, ylimit=(0,yl1),mode="markers",markersize=0.5,legend=false,ylabel=L"\mathrm{N_(Left)}}")
  #  xlabel!("Time (s)", xguidefont=font(11), xtickfont=font(11))
  #  plot!(ylabel=L"\mathrm{N_{eqs}}",yguidefont=font(11), ytickfont=font(11))
   t2=scatter(time,n_right, ylimit=(0,yl1),mode="markers",markersize=0.5,legend=false, ylabel=L"\mathrm{N_{(Right)}}")

   t3=scatter(time,(n_left.-n_right), ylimit=(-yl1,yl1),mode="markers",markersize=0.5,legend=false,ylabel=L"\mathrm{N_{(Left)}}-\mathrm{N_{(Right)}}") 

   p= plot(t3)
   q= plot(t1,t2, layout=(2,1))
   savefig(q,f2)
   savefig(p,f3)
   
    #creating DataFrame for number of particles at equators n1, and at poles n2
    data = DataFrame(t= time, Nleft = n_left, Nright = n_right)
     CSV.write(f1, data)
    close(efg)
     println("I am out of ABP symmetry_analysis")
 return nothing
end


function curvature_analysis(a,b,R,time,gdf,pathf,δt)
 
  f5= pathf*"_p.csv"
  f6= pathf*"_N.png"
  f7= pathf*"_Ndiff_eqs.png"
  f8= pathf*"_curvature_phenomenon.png"
  f8= pathf*"_Ndiff_curvature.png"
  n1,n2,n3,n4=[], [], [], []

  i= (time/δt)
  eθ = atan(b/a)   # angle at which area will be same
# pf_factor = R*R
# Aeq= a*b*(atan(a*tan(eθ)/b))  # equator area
# Ap= a*b*(atan(b/(tan(eθ)*a)))   # pole area

for i=1:length(gdf)      # length(gdf) is total time or steps, i is actually time steps but in group counting it is 1, 2, 3---1000 , hence, time                                                                                                                                                                                                                     

   global Npole1=0
   global Npole2=0
   global Neq1=0
   global Neq2=0
  
   
    for j=1:length(gdf[i][!,:xpos]) 
    
        θ = atan.(gdf[i][!,:ypos][j], gdf[i][!,:xpos][j]) 

        if θ.>= (π-eθ)  && θ.<= π                    #equator Left                                                                                                                                                                                      
           global  Neq1+=1  
        elseif θ.>= -π  && θ.<= -(π-eθ)  
            global   Neq1+=1
          elseif θ.>= -eθ  &&  θ.<= eθ              #equator Right                                                                                                                                                                                           
              global   Neq2+=1  
                
                elseif θ.>= eθ && θ.<= (π-eθ)        #pole up
              global  Npole1+=1 
                elseif θ.>= -(π-eθ)   && θ.<= - eθ      #pole down
                global    Npole2+=1 
    end   
    
    end
    push!(n1,Neq1)
    push!(n2,Neq2)
    push!(n3,Npole1)
    push!(n4,Npole2)
    #println("$count1, $count2, $i") 
    
    # pfe = count1*(0.5*π/Aeq)*pf_factor 
    # pfp = count2*(0.5*π/Ap)*pf_factor 
  
 end

  
############################################################################################################
#file wriiting
    touch(f5)

    efg = open(f5, "w")
    # time1= unique(df[!,:StepN])   # not to repeat the time in data

        #########################################################################################
    # ploting in terms of particles number
    yl=30
    xl=100
    y2=500
  #  xlabel!("Time (s)", xguidefont=font(11), xtickfont=font(11))
  #  plot!(ylabel=L"\mathrm{N_{eqs}}",yguidefont=font(11), ytickfont=font(11))
   
   t1= scatter(time,n1, ylimit=(0,yl),mode="markers",markersize=0.5,legend=false,ylabel=L"\mathrm{N_{Eq(L)}}")
  #  xlabel!("Time (s)", xguidefont=font(11), xtickfont=font(11))
  #  plot!(ylabel=L"\mathrm{N_{eqs}}",yguidefont=font(11), ytickfont=font(11))
   t2=scatter(time,n2, ylimit=(0,yl),mode="markers",markersize=0.5,legend=false, ylabel=L"\mathrm{N_{Eq(R)}}")
   t3=scatter(time,n3, ylimit=(0,yl),mode="markers",markersize=0.5,legend=false,ylabel=L"\mathrm{N_{Pole(U)}}") 
  
 
   t4=scatter(time,n4, ylimit=(0,yl),mode="markers",markersize=0.5,legend=false,ylabel=L"\mathrm{N_{Pole(D)}}") 

   t5=scatter(time,n1.-n2, ylimit=(-yl,yl),mode="markers",markersize=0.5,legend=false,ylabel=L"\mathrm{N_{Eq(L)}}-\mathrm{N_{Eq(R)}}") 

   t6= scatter(time,n3.-n4, ylimit=(-yl,yl),mode="markers",markersize=0.02,legend=false,ylabel=L"\mathrm{N_{Pole(U)}}-\mathrm{N_{Pole(D)}}") 

   t7= scatter(time,n1.+n2, ylimit=(0,y2),mode="markers",markersize=0.5,legend=false,ylabel=L"\mathrm{N_{Eq}}")

   p= plot(t1,t2,t3,t4, layout=(2,2))

   q= plot(t5,t6, layout=(2,1))
   savefig(p,f6)
   savefig(q,f7)
   savefig(k,f8)
   
    #creating DataFrame for number of particles at equators n1, and at poles n2
    data = DataFrame(t= time, NeqL = n1, NeqR = n2, NpoleU = n3, NpoleD = n4)
     CSV.write(f5, data)
     close(efg)
   
    println("I am out of ABP analysis")
 return nothing
end



  #########################################################################################
    # ploting in terms of packing fraction

    #=
    scatter!(t1,[i],[pfe], ylimit=(0,0.3),legend=false) 
    xlabel!("Time (s)", xguidefont=font(16), xtickfont=font(11))
    plot!(ylabel=L"\mathrm{pf_{eqs}}",yguidefont=font(16), ytickfont=font(11))
    title!(" Equators ")
    
    scatter!(t2,[i],[pfp], ylimit=(0,0.3),legend=false) 
    xlabel!("Time (s)", xguidefont=font(16), xtickfont=font(11))
    plot!(ylabel=L"\mathrm{pf_{poles}}",yguidefont=font(16), ytickfont=font(11))
    title!(" Poles ")
    #count= count1+count2
    end
plot(t1, t2)
savefig(f2)
   =# 
